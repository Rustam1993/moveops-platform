// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
  tenant_id,
  first_name,
  last_name,
  email,
  phone,
  created_by,
  updated_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
RETURNING id, tenant_id, first_name, last_name, email, phone, created_by, updated_by, created_at, updated_at
`

type CreateCustomerParams struct {
	TenantID  uuid.UUID  `json:"tenant_id"`
	FirstName string     `json:"first_name"`
	LastName  string     `json:"last_name"`
	Email     *string    `json:"email"`
	Phone     *string    `json:"phone"`
	CreatedBy *uuid.UUID `json:"created_by"`
	UpdatedBy *uuid.UUID `json:"updated_by"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.TenantID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCustomerForEstimate = `-- name: CreateCustomerForEstimate :one
INSERT INTO customers (
  tenant_id,
  first_name,
  last_name,
  email,
  phone,
  created_by,
  updated_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
RETURNING id, tenant_id, first_name, last_name, email, phone, created_by, updated_by, created_at, updated_at
`

type CreateCustomerForEstimateParams struct {
	TenantID  uuid.UUID  `json:"tenant_id"`
	FirstName string     `json:"first_name"`
	LastName  string     `json:"last_name"`
	Email     *string    `json:"email"`
	Phone     *string    `json:"phone"`
	CreatedBy *uuid.UUID `json:"created_by"`
	UpdatedBy *uuid.UUID `json:"updated_by"`
}

func (q *Queries) CreateCustomerForEstimate(ctx context.Context, arg CreateCustomerForEstimateParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomerForEstimate,
		arg.TenantID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEstimate = `-- name: CreateEstimate :one
INSERT INTO estimates (
  tenant_id,
  estimate_number,
  customer_id,
  status,
  customer_name,
  primary_phone,
  secondary_phone,
  email,
  origin_address_line1,
  origin_city,
  origin_state,
  origin_postal_code,
  destination_address_line1,
  destination_city,
  destination_state,
  destination_postal_code,
  move_date,
  pickup_time,
  lead_source,
  move_size,
  location_type,
  estimated_total_cents,
  deposit_cents,
  notes,
  idempotency_key,
  idempotency_payload_hash,
  created_by,
  updated_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  $18,
  $19,
  $20,
  $21,
  $22,
  $23,
  $24,
  $25,
  $26,
  $27,
  $28
)
RETURNING id, tenant_id, estimate_number, customer_id, status, customer_name, primary_phone, secondary_phone, email, origin_address_line1, origin_city, origin_state, origin_postal_code, destination_address_line1, destination_city, destination_state, destination_postal_code, move_date, pickup_time, lead_source, move_size, location_type, estimated_total_cents, deposit_cents, notes, idempotency_key, idempotency_payload_hash, created_by, updated_by, created_at, updated_at
`

type CreateEstimateParams struct {
	TenantID                uuid.UUID  `json:"tenant_id"`
	EstimateNumber          string     `json:"estimate_number"`
	CustomerID              uuid.UUID  `json:"customer_id"`
	Status                  string     `json:"status"`
	CustomerName            string     `json:"customer_name"`
	PrimaryPhone            string     `json:"primary_phone"`
	SecondaryPhone          *string    `json:"secondary_phone"`
	Email                   string     `json:"email"`
	OriginAddressLine1      string     `json:"origin_address_line1"`
	OriginCity              string     `json:"origin_city"`
	OriginState             string     `json:"origin_state"`
	OriginPostalCode        string     `json:"origin_postal_code"`
	DestinationAddressLine1 string     `json:"destination_address_line1"`
	DestinationCity         string     `json:"destination_city"`
	DestinationState        string     `json:"destination_state"`
	DestinationPostalCode   string     `json:"destination_postal_code"`
	MoveDate                time.Time  `json:"move_date"`
	PickupTime              *string    `json:"pickup_time"`
	LeadSource              string     `json:"lead_source"`
	MoveSize                *string    `json:"move_size"`
	LocationType            *string    `json:"location_type"`
	EstimatedTotalCents     *int64     `json:"estimated_total_cents"`
	DepositCents            *int64     `json:"deposit_cents"`
	Notes                   *string    `json:"notes"`
	IdempotencyKey          *string    `json:"idempotency_key"`
	IdempotencyPayloadHash  *string    `json:"idempotency_payload_hash"`
	CreatedBy               *uuid.UUID `json:"created_by"`
	UpdatedBy               *uuid.UUID `json:"updated_by"`
}

func (q *Queries) CreateEstimate(ctx context.Context, arg CreateEstimateParams) (Estimate, error) {
	row := q.db.QueryRow(ctx, createEstimate,
		arg.TenantID,
		arg.EstimateNumber,
		arg.CustomerID,
		arg.Status,
		arg.CustomerName,
		arg.PrimaryPhone,
		arg.SecondaryPhone,
		arg.Email,
		arg.OriginAddressLine1,
		arg.OriginCity,
		arg.OriginState,
		arg.OriginPostalCode,
		arg.DestinationAddressLine1,
		arg.DestinationCity,
		arg.DestinationState,
		arg.DestinationPostalCode,
		arg.MoveDate,
		arg.PickupTime,
		arg.LeadSource,
		arg.MoveSize,
		arg.LocationType,
		arg.EstimatedTotalCents,
		arg.DepositCents,
		arg.Notes,
		arg.IdempotencyKey,
		arg.IdempotencyPayloadHash,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Estimate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EstimateNumber,
		&i.CustomerID,
		&i.Status,
		&i.CustomerName,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.Email,
		&i.OriginAddressLine1,
		&i.OriginCity,
		&i.OriginState,
		&i.OriginPostalCode,
		&i.DestinationAddressLine1,
		&i.DestinationCity,
		&i.DestinationState,
		&i.DestinationPostalCode,
		&i.MoveDate,
		&i.PickupTime,
		&i.LeadSource,
		&i.MoveSize,
		&i.LocationType,
		&i.EstimatedTotalCents,
		&i.DepositCents,
		&i.Notes,
		&i.IdempotencyKey,
		&i.IdempotencyPayloadHash,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
  tenant_id,
  job_number,
  estimate_id,
  customer_id,
  status,
  scheduled_date,
  pickup_time,
  convert_idempotency_key,
  created_by,
  updated_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10
)
RETURNING id, tenant_id, job_number, estimate_id, customer_id, status, scheduled_date, pickup_time, convert_idempotency_key, created_by, updated_by, created_at, updated_at
`

type CreateJobParams struct {
	TenantID              uuid.UUID  `json:"tenant_id"`
	JobNumber             string     `json:"job_number"`
	EstimateID            *uuid.UUID `json:"estimate_id"`
	CustomerID            uuid.UUID  `json:"customer_id"`
	Status                string     `json:"status"`
	ScheduledDate         *time.Time `json:"scheduled_date"`
	PickupTime            *string    `json:"pickup_time"`
	ConvertIdempotencyKey *string    `json:"convert_idempotency_key"`
	CreatedBy             *uuid.UUID `json:"created_by"`
	UpdatedBy             *uuid.UUID `json:"updated_by"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.TenantID,
		arg.JobNumber,
		arg.EstimateID,
		arg.CustomerID,
		arg.Status,
		arg.ScheduledDate,
		arg.PickupTime,
		arg.ConvertIdempotencyKey,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
  tenant_id,
  user_id,
  token_hash,
  csrf_token,
  expires_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
RETURNING id, tenant_id, user_id, token_hash, csrf_token, created_at, expires_at, last_seen_at, revoked_at
`

type CreateSessionParams struct {
	TenantID  uuid.UUID `json:"tenant_id"`
	UserID    uuid.UUID `json:"user_id"`
	TokenHash string    `json:"token_hash"`
	CsrfToken string    `json:"csrf_token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.TenantID,
		arg.UserID,
		arg.TokenHash,
		arg.CsrfToken,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.TokenHash,
		&i.CsrfToken,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastSeenAt,
		&i.RevokedAt,
	)
	return i, err
}

const getCustomerByID = `-- name: GetCustomerByID :one
SELECT
  id,
  tenant_id,
  first_name,
  last_name,
  email,
  phone,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM customers
WHERE id = $1
  AND tenant_id = $2
`

type GetCustomerByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetCustomerByID(ctx context.Context, arg GetCustomerByIDParams) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByID, arg.ID, arg.TenantID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEstimateByID = `-- name: GetEstimateByID :one
SELECT
  id,
  tenant_id,
  estimate_number,
  customer_id,
  status,
  customer_name,
  primary_phone,
  secondary_phone,
  email,
  origin_address_line1,
  origin_city,
  origin_state,
  origin_postal_code,
  destination_address_line1,
  destination_city,
  destination_state,
  destination_postal_code,
  move_date,
  pickup_time,
  lead_source,
  move_size,
  location_type,
  estimated_total_cents,
  deposit_cents,
  notes,
  idempotency_key,
  idempotency_payload_hash,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM estimates
WHERE id = $1
  AND tenant_id = $2
`

type GetEstimateByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetEstimateByID(ctx context.Context, arg GetEstimateByIDParams) (Estimate, error) {
	row := q.db.QueryRow(ctx, getEstimateByID, arg.ID, arg.TenantID)
	var i Estimate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EstimateNumber,
		&i.CustomerID,
		&i.Status,
		&i.CustomerName,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.Email,
		&i.OriginAddressLine1,
		&i.OriginCity,
		&i.OriginState,
		&i.OriginPostalCode,
		&i.DestinationAddressLine1,
		&i.DestinationCity,
		&i.DestinationState,
		&i.DestinationPostalCode,
		&i.MoveDate,
		&i.PickupTime,
		&i.LeadSource,
		&i.MoveSize,
		&i.LocationType,
		&i.EstimatedTotalCents,
		&i.DepositCents,
		&i.Notes,
		&i.IdempotencyKey,
		&i.IdempotencyPayloadHash,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEstimateByIdempotencyKey = `-- name: GetEstimateByIdempotencyKey :one
SELECT
  id,
  tenant_id,
  estimate_number,
  customer_id,
  status,
  customer_name,
  primary_phone,
  secondary_phone,
  email,
  origin_address_line1,
  origin_city,
  origin_state,
  origin_postal_code,
  destination_address_line1,
  destination_city,
  destination_state,
  destination_postal_code,
  move_date,
  pickup_time,
  lead_source,
  move_size,
  location_type,
  estimated_total_cents,
  deposit_cents,
  notes,
  idempotency_key,
  idempotency_payload_hash,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM estimates
WHERE tenant_id = $1
  AND idempotency_key = $2
`

type GetEstimateByIdempotencyKeyParams struct {
	TenantID       uuid.UUID `json:"tenant_id"`
	IdempotencyKey *string   `json:"idempotency_key"`
}

func (q *Queries) GetEstimateByIdempotencyKey(ctx context.Context, arg GetEstimateByIdempotencyKeyParams) (Estimate, error) {
	row := q.db.QueryRow(ctx, getEstimateByIdempotencyKey, arg.TenantID, arg.IdempotencyKey)
	var i Estimate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EstimateNumber,
		&i.CustomerID,
		&i.Status,
		&i.CustomerName,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.Email,
		&i.OriginAddressLine1,
		&i.OriginCity,
		&i.OriginState,
		&i.OriginPostalCode,
		&i.DestinationAddressLine1,
		&i.DestinationCity,
		&i.DestinationState,
		&i.DestinationPostalCode,
		&i.MoveDate,
		&i.PickupTime,
		&i.LeadSource,
		&i.MoveSize,
		&i.LocationType,
		&i.EstimatedTotalCents,
		&i.DepositCents,
		&i.Notes,
		&i.IdempotencyKey,
		&i.IdempotencyPayloadHash,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEstimateDetailByID = `-- name: GetEstimateDetailByID :one
SELECT
  e.id,
  e.tenant_id,
  e.estimate_number,
  e.customer_id,
  e.status,
  e.customer_name,
  e.primary_phone,
  e.secondary_phone,
  e.email,
  e.origin_address_line1,
  e.origin_city,
  e.origin_state,
  e.origin_postal_code,
  e.destination_address_line1,
  e.destination_city,
  e.destination_state,
  e.destination_postal_code,
  e.move_date,
  e.pickup_time,
  e.lead_source,
  e.move_size,
  e.location_type,
  e.estimated_total_cents,
  e.deposit_cents,
  e.notes,
  e.idempotency_key,
  e.idempotency_payload_hash,
  e.created_by,
  e.updated_by,
  e.created_at,
  e.updated_at,
  j.id AS converted_job_id
FROM estimates e
LEFT JOIN jobs j
  ON j.tenant_id = e.tenant_id
  AND j.estimate_id = e.id
WHERE e.id = $1
  AND e.tenant_id = $2
`

type GetEstimateDetailByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

type GetEstimateDetailByIDRow struct {
	ID                      uuid.UUID  `json:"id"`
	TenantID                uuid.UUID  `json:"tenant_id"`
	EstimateNumber          string     `json:"estimate_number"`
	CustomerID              uuid.UUID  `json:"customer_id"`
	Status                  string     `json:"status"`
	CustomerName            string     `json:"customer_name"`
	PrimaryPhone            string     `json:"primary_phone"`
	SecondaryPhone          *string    `json:"secondary_phone"`
	Email                   string     `json:"email"`
	OriginAddressLine1      string     `json:"origin_address_line1"`
	OriginCity              string     `json:"origin_city"`
	OriginState             string     `json:"origin_state"`
	OriginPostalCode        string     `json:"origin_postal_code"`
	DestinationAddressLine1 string     `json:"destination_address_line1"`
	DestinationCity         string     `json:"destination_city"`
	DestinationState        string     `json:"destination_state"`
	DestinationPostalCode   string     `json:"destination_postal_code"`
	MoveDate                time.Time  `json:"move_date"`
	PickupTime              *string    `json:"pickup_time"`
	LeadSource              string     `json:"lead_source"`
	MoveSize                *string    `json:"move_size"`
	LocationType            *string    `json:"location_type"`
	EstimatedTotalCents     *int64     `json:"estimated_total_cents"`
	DepositCents            *int64     `json:"deposit_cents"`
	Notes                   *string    `json:"notes"`
	IdempotencyKey          *string    `json:"idempotency_key"`
	IdempotencyPayloadHash  *string    `json:"idempotency_payload_hash"`
	CreatedBy               *uuid.UUID `json:"created_by"`
	UpdatedBy               *uuid.UUID `json:"updated_by"`
	CreatedAt               time.Time  `json:"created_at"`
	UpdatedAt               time.Time  `json:"updated_at"`
	ConvertedJobID          *uuid.UUID `json:"converted_job_id"`
}

func (q *Queries) GetEstimateDetailByID(ctx context.Context, arg GetEstimateDetailByIDParams) (GetEstimateDetailByIDRow, error) {
	row := q.db.QueryRow(ctx, getEstimateDetailByID, arg.ID, arg.TenantID)
	var i GetEstimateDetailByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EstimateNumber,
		&i.CustomerID,
		&i.Status,
		&i.CustomerName,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.Email,
		&i.OriginAddressLine1,
		&i.OriginCity,
		&i.OriginState,
		&i.OriginPostalCode,
		&i.DestinationAddressLine1,
		&i.DestinationCity,
		&i.DestinationState,
		&i.DestinationPostalCode,
		&i.MoveDate,
		&i.PickupTime,
		&i.LeadSource,
		&i.MoveSize,
		&i.LocationType,
		&i.EstimatedTotalCents,
		&i.DepositCents,
		&i.Notes,
		&i.IdempotencyKey,
		&i.IdempotencyPayloadHash,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConvertedJobID,
	)
	return i, err
}

const getJobByConvertIdempotencyKey = `-- name: GetJobByConvertIdempotencyKey :one
SELECT
  id,
  tenant_id,
  job_number,
  estimate_id,
  customer_id,
  status,
  scheduled_date,
  pickup_time,
  convert_idempotency_key,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM jobs
WHERE tenant_id = $1
  AND convert_idempotency_key = $2
`

type GetJobByConvertIdempotencyKeyParams struct {
	TenantID              uuid.UUID `json:"tenant_id"`
	ConvertIdempotencyKey *string   `json:"convert_idempotency_key"`
}

func (q *Queries) GetJobByConvertIdempotencyKey(ctx context.Context, arg GetJobByConvertIdempotencyKeyParams) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByConvertIdempotencyKey, arg.TenantID, arg.ConvertIdempotencyKey)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobByEstimateID = `-- name: GetJobByEstimateID :one
SELECT
  id,
  tenant_id,
  job_number,
  estimate_id,
  customer_id,
  status,
  scheduled_date,
  pickup_time,
  convert_idempotency_key,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM jobs
WHERE tenant_id = $1
  AND estimate_id = $2
`

type GetJobByEstimateIDParams struct {
	TenantID   uuid.UUID  `json:"tenant_id"`
	EstimateID *uuid.UUID `json:"estimate_id"`
}

func (q *Queries) GetJobByEstimateID(ctx context.Context, arg GetJobByEstimateIDParams) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByEstimateID, arg.TenantID, arg.EstimateID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobByID = `-- name: GetJobByID :one
SELECT
  id,
  tenant_id,
  job_number,
  estimate_id,
  customer_id,
  status,
  scheduled_date,
  pickup_time,
  convert_idempotency_key,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM jobs
WHERE id = $1
  AND tenant_id = $2
`

type GetJobByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetJobByID(ctx context.Context, arg GetJobByIDParams) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByID, arg.ID, arg.TenantID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobDetailByID = `-- name: GetJobDetailByID :one
SELECT
  j.id,
  j.tenant_id,
  j.job_number,
  j.estimate_id,
  j.customer_id,
  j.status,
  j.scheduled_date,
  j.pickup_time,
  j.convert_idempotency_key,
  j.created_by,
  j.updated_by,
  j.created_at,
  j.updated_at,
  c.first_name,
  c.last_name,
  COALESCE(c.phone, e.primary_phone, '') AS phone,
  COALESCE(c.email, e.email, 'no-reply@moveops.local') AS email
FROM jobs j
JOIN customers c
  ON c.id = j.customer_id
  AND c.tenant_id = j.tenant_id
LEFT JOIN estimates e
  ON e.id = j.estimate_id
  AND e.tenant_id = j.tenant_id
WHERE j.id = $1
  AND j.tenant_id = $2
`

type GetJobDetailByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

type GetJobDetailByIDRow struct {
	ID                    uuid.UUID  `json:"id"`
	TenantID              uuid.UUID  `json:"tenant_id"`
	JobNumber             string     `json:"job_number"`
	EstimateID            *uuid.UUID `json:"estimate_id"`
	CustomerID            uuid.UUID  `json:"customer_id"`
	Status                string     `json:"status"`
	ScheduledDate         *time.Time `json:"scheduled_date"`
	PickupTime            *string    `json:"pickup_time"`
	ConvertIdempotencyKey *string    `json:"convert_idempotency_key"`
	CreatedBy             *uuid.UUID `json:"created_by"`
	UpdatedBy             *uuid.UUID `json:"updated_by"`
	CreatedAt             time.Time  `json:"created_at"`
	UpdatedAt             time.Time  `json:"updated_at"`
	FirstName             string     `json:"first_name"`
	LastName              string     `json:"last_name"`
	Phone                 string     `json:"phone"`
	Email                 string     `json:"email"`
}

func (q *Queries) GetJobDetailByID(ctx context.Context, arg GetJobDetailByIDParams) (GetJobDetailByIDRow, error) {
	row := q.db.QueryRow(ctx, getJobDetailByID, arg.ID, arg.TenantID)
	var i GetJobDetailByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Email,
	)
	return i, err
}

const getSessionPrincipalByTokenHash = `-- name: GetSessionPrincipalByTokenHash :one
SELECT
  s.id AS session_id,
  s.tenant_id,
  s.user_id,
  s.csrf_token,
  s.expires_at,
  u.email,
  u.full_name,
  t.slug AS tenant_slug,
  t.name AS tenant_name
FROM sessions s
JOIN users u ON u.id = s.user_id
JOIN tenants t ON t.id = s.tenant_id
WHERE s.token_hash = $1
  AND s.revoked_at IS NULL
  AND s.expires_at > NOW()
  AND u.is_active = TRUE
`

type GetSessionPrincipalByTokenHashRow struct {
	SessionID  uuid.UUID `json:"session_id"`
	TenantID   uuid.UUID `json:"tenant_id"`
	UserID     uuid.UUID `json:"user_id"`
	CsrfToken  string    `json:"csrf_token"`
	ExpiresAt  time.Time `json:"expires_at"`
	Email      string    `json:"email"`
	FullName   string    `json:"full_name"`
	TenantSlug string    `json:"tenant_slug"`
	TenantName string    `json:"tenant_name"`
}

func (q *Queries) GetSessionPrincipalByTokenHash(ctx context.Context, tokenHash string) (GetSessionPrincipalByTokenHashRow, error) {
	row := q.db.QueryRow(ctx, getSessionPrincipalByTokenHash, tokenHash)
	var i GetSessionPrincipalByTokenHashRow
	err := row.Scan(
		&i.SessionID,
		&i.TenantID,
		&i.UserID,
		&i.CsrfToken,
		&i.ExpiresAt,
		&i.Email,
		&i.FullName,
		&i.TenantSlug,
		&i.TenantName,
	)
	return i, err
}

const incrementTenantCounter = `-- name: IncrementTenantCounter :one
INSERT INTO tenant_counters (tenant_id, counter_type, next_value)
VALUES ($1, $2, 2)
ON CONFLICT (tenant_id, counter_type) DO UPDATE
SET
  next_value = tenant_counters.next_value + 1,
  updated_at = NOW()
RETURNING (next_value - 1)::bigint AS value
`

type IncrementTenantCounterParams struct {
	TenantID    uuid.UUID `json:"tenant_id"`
	CounterType string    `json:"counter_type"`
}

func (q *Queries) IncrementTenantCounter(ctx context.Context, arg IncrementTenantCounterParams) (int64, error) {
	row := q.db.QueryRow(ctx, incrementTenantCounter, arg.TenantID, arg.CounterType)
	var value int64
	err := row.Scan(&value)
	return value, err
}

const insertAuditLog = `-- name: InsertAuditLog :exec
INSERT INTO audit_log (
  tenant_id,
  user_id,
  action,
  entity_type,
  entity_id,
  request_id,
  metadata
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
`

type InsertAuditLogParams struct {
	TenantID   uuid.UUID  `json:"tenant_id"`
	UserID     *uuid.UUID `json:"user_id"`
	Action     string     `json:"action"`
	EntityType string     `json:"entity_type"`
	EntityID   *uuid.UUID `json:"entity_id"`
	RequestID  *string    `json:"request_id"`
	Metadata   []byte     `json:"metadata"`
}

func (q *Queries) InsertAuditLog(ctx context.Context, arg InsertAuditLogParams) error {
	_, err := q.db.Exec(ctx, insertAuditLog,
		arg.TenantID,
		arg.UserID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.RequestID,
		arg.Metadata,
	)
	return err
}

const listUsersByEmail = `-- name: ListUsersByEmail :many
SELECT
  u.id,
  u.tenant_id,
  u.email,
  u.full_name,
  u.password_hash,
  u.is_active,
  t.slug AS tenant_slug,
  t.name AS tenant_name
FROM users u
JOIN tenants t ON t.id = u.tenant_id
WHERE lower(u.email) = lower($1)
`

type ListUsersByEmailRow struct {
	ID           uuid.UUID `json:"id"`
	TenantID     uuid.UUID `json:"tenant_id"`
	Email        string    `json:"email"`
	FullName     string    `json:"full_name"`
	PasswordHash string    `json:"password_hash"`
	IsActive     bool      `json:"is_active"`
	TenantSlug   string    `json:"tenant_slug"`
	TenantName   string    `json:"tenant_name"`
}

func (q *Queries) ListUsersByEmail(ctx context.Context, email string) ([]ListUsersByEmailRow, error) {
	rows, err := q.db.Query(ctx, listUsersByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersByEmailRow{}
	for rows.Next() {
		var i ListUsersByEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Email,
			&i.FullName,
			&i.PasswordHash,
			&i.IsActive,
			&i.TenantSlug,
			&i.TenantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEstimateConverted = `-- name: MarkEstimateConverted :execrows
UPDATE estimates
SET
  status = 'converted',
  updated_by = $1,
  updated_at = NOW()
WHERE id = $2
  AND tenant_id = $3
  AND status <> 'converted'
`

type MarkEstimateConvertedParams struct {
	UpdatedBy *uuid.UUID `json:"updated_by"`
	ID        uuid.UUID  `json:"id"`
	TenantID  uuid.UUID  `json:"tenant_id"`
}

func (q *Queries) MarkEstimateConverted(ctx context.Context, arg MarkEstimateConvertedParams) (int64, error) {
	result, err := q.db.Exec(ctx, markEstimateConverted, arg.UpdatedBy, arg.ID, arg.TenantID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const revokeSessionByID = `-- name: RevokeSessionByID :execrows
UPDATE sessions
SET revoked_at = NOW()
WHERE id = $1
  AND tenant_id = $2
  AND revoked_at IS NULL
`

type RevokeSessionByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) RevokeSessionByID(ctx context.Context, arg RevokeSessionByIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, revokeSessionByID, arg.ID, arg.TenantID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const revokeSessionByTokenHash = `-- name: RevokeSessionByTokenHash :execrows
UPDATE sessions
SET revoked_at = NOW()
WHERE token_hash = $1
  AND revoked_at IS NULL
`

func (q *Queries) RevokeSessionByTokenHash(ctx context.Context, tokenHash string) (int64, error) {
	result, err := q.db.Exec(ctx, revokeSessionByTokenHash, tokenHash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const touchSession = `-- name: TouchSession :exec
UPDATE sessions
SET last_seen_at = NOW()
WHERE id = $1
`

func (q *Queries) TouchSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, touchSession, id)
	return err
}

const updateCustomerForEstimate = `-- name: UpdateCustomerForEstimate :one
UPDATE customers
SET
  first_name = COALESCE($1, first_name),
  last_name = COALESCE($2, last_name),
  email = COALESCE($3, email),
  phone = COALESCE($4, phone),
  updated_by = $5,
  updated_at = NOW()
WHERE id = $6
  AND tenant_id = $7
RETURNING id, tenant_id, first_name, last_name, email, phone, created_by, updated_by, created_at, updated_at
`

type UpdateCustomerForEstimateParams struct {
	FirstName *string    `json:"first_name"`
	LastName  *string    `json:"last_name"`
	Email     *string    `json:"email"`
	Phone     *string    `json:"phone"`
	UpdatedBy *uuid.UUID `json:"updated_by"`
	ID        uuid.UUID  `json:"id"`
	TenantID  uuid.UUID  `json:"tenant_id"`
}

func (q *Queries) UpdateCustomerForEstimate(ctx context.Context, arg UpdateCustomerForEstimateParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomerForEstimate,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.UpdatedBy,
		arg.ID,
		arg.TenantID,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEstimate = `-- name: UpdateEstimate :one
UPDATE estimates
SET
  customer_name = COALESCE($1, customer_name),
  primary_phone = COALESCE($2, primary_phone),
  secondary_phone = COALESCE($3, secondary_phone),
  email = COALESCE($4, email),
  origin_address_line1 = COALESCE($5, origin_address_line1),
  origin_city = COALESCE($6, origin_city),
  origin_state = COALESCE($7, origin_state),
  origin_postal_code = COALESCE($8, origin_postal_code),
  destination_address_line1 = COALESCE($9, destination_address_line1),
  destination_city = COALESCE($10, destination_city),
  destination_state = COALESCE($11, destination_state),
  destination_postal_code = COALESCE($12, destination_postal_code),
  move_date = COALESCE($13::date, move_date),
  pickup_time = COALESCE($14, pickup_time),
  lead_source = COALESCE($15, lead_source),
  move_size = COALESCE($16, move_size),
  location_type = COALESCE($17, location_type),
  estimated_total_cents = COALESCE($18::bigint, estimated_total_cents),
  deposit_cents = COALESCE($19::bigint, deposit_cents),
  notes = COALESCE($20, notes),
  updated_by = $21,
  updated_at = NOW()
WHERE id = $22
  AND tenant_id = $23
RETURNING id, tenant_id, estimate_number, customer_id, status, customer_name, primary_phone, secondary_phone, email, origin_address_line1, origin_city, origin_state, origin_postal_code, destination_address_line1, destination_city, destination_state, destination_postal_code, move_date, pickup_time, lead_source, move_size, location_type, estimated_total_cents, deposit_cents, notes, idempotency_key, idempotency_payload_hash, created_by, updated_by, created_at, updated_at
`

type UpdateEstimateParams struct {
	CustomerName            *string    `json:"customer_name"`
	PrimaryPhone            *string    `json:"primary_phone"`
	SecondaryPhone          *string    `json:"secondary_phone"`
	Email                   *string    `json:"email"`
	OriginAddressLine1      *string    `json:"origin_address_line1"`
	OriginCity              *string    `json:"origin_city"`
	OriginState             *string    `json:"origin_state"`
	OriginPostalCode        *string    `json:"origin_postal_code"`
	DestinationAddressLine1 *string    `json:"destination_address_line1"`
	DestinationCity         *string    `json:"destination_city"`
	DestinationState        *string    `json:"destination_state"`
	DestinationPostalCode   *string    `json:"destination_postal_code"`
	MoveDate                *time.Time `json:"move_date"`
	PickupTime              *string    `json:"pickup_time"`
	LeadSource              *string    `json:"lead_source"`
	MoveSize                *string    `json:"move_size"`
	LocationType            *string    `json:"location_type"`
	EstimatedTotalCents     *int64     `json:"estimated_total_cents"`
	DepositCents            *int64     `json:"deposit_cents"`
	Notes                   *string    `json:"notes"`
	UpdatedBy               *uuid.UUID `json:"updated_by"`
	ID                      uuid.UUID  `json:"id"`
	TenantID                uuid.UUID  `json:"tenant_id"`
}

func (q *Queries) UpdateEstimate(ctx context.Context, arg UpdateEstimateParams) (Estimate, error) {
	row := q.db.QueryRow(ctx, updateEstimate,
		arg.CustomerName,
		arg.PrimaryPhone,
		arg.SecondaryPhone,
		arg.Email,
		arg.OriginAddressLine1,
		arg.OriginCity,
		arg.OriginState,
		arg.OriginPostalCode,
		arg.DestinationAddressLine1,
		arg.DestinationCity,
		arg.DestinationState,
		arg.DestinationPostalCode,
		arg.MoveDate,
		arg.PickupTime,
		arg.LeadSource,
		arg.MoveSize,
		arg.LocationType,
		arg.EstimatedTotalCents,
		arg.DepositCents,
		arg.Notes,
		arg.UpdatedBy,
		arg.ID,
		arg.TenantID,
	)
	var i Estimate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EstimateNumber,
		&i.CustomerID,
		&i.Status,
		&i.CustomerName,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.Email,
		&i.OriginAddressLine1,
		&i.OriginCity,
		&i.OriginState,
		&i.OriginPostalCode,
		&i.DestinationAddressLine1,
		&i.DestinationCity,
		&i.DestinationState,
		&i.DestinationPostalCode,
		&i.MoveDate,
		&i.PickupTime,
		&i.LeadSource,
		&i.MoveSize,
		&i.LocationType,
		&i.EstimatedTotalCents,
		&i.DepositCents,
		&i.Notes,
		&i.IdempotencyKey,
		&i.IdempotencyPayloadHash,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateJobScheduleStatus = `-- name: UpdateJobScheduleStatus :one
UPDATE jobs
SET
  scheduled_date = COALESCE($1::date, scheduled_date),
  pickup_time = COALESCE($2, pickup_time),
  status = COALESCE($3, status),
  updated_by = $4,
  updated_at = NOW()
WHERE id = $5
  AND tenant_id = $6
RETURNING id, tenant_id, job_number, estimate_id, customer_id, status, scheduled_date, pickup_time, convert_idempotency_key, created_by, updated_by, created_at, updated_at
`

type UpdateJobScheduleStatusParams struct {
	ScheduledDate *time.Time `json:"scheduled_date"`
	PickupTime    *string    `json:"pickup_time"`
	Status        *string    `json:"status"`
	UpdatedBy     *uuid.UUID `json:"updated_by"`
	ID            uuid.UUID  `json:"id"`
	TenantID      uuid.UUID  `json:"tenant_id"`
}

func (q *Queries) UpdateJobScheduleStatus(ctx context.Context, arg UpdateJobScheduleStatusParams) (Job, error) {
	row := q.db.QueryRow(ctx, updateJobScheduleStatus,
		arg.ScheduledDate,
		arg.PickupTime,
		arg.Status,
		arg.UpdatedBy,
		arg.ID,
		arg.TenantID,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const userHasPermission = `-- name: UserHasPermission :one
SELECT EXISTS (
  SELECT 1
  FROM user_roles ur
  JOIN roles r ON r.id = ur.role_id
  JOIN role_permissions rp ON rp.role_id = r.id
  JOIN permissions p ON p.id = rp.permission_id
  WHERE ur.user_id = $1
    AND ur.tenant_id = $2
    AND r.tenant_id = $2
    AND p.name = $3
) AS has_permission
`

type UserHasPermissionParams struct {
	UserID     uuid.UUID `json:"user_id"`
	TenantID   uuid.UUID `json:"tenant_id"`
	Permission string    `json:"permission"`
}

func (q *Queries) UserHasPermission(ctx context.Context, arg UserHasPermissionParams) (bool, error) {
	row := q.db.QueryRow(ctx, userHasPermission, arg.UserID, arg.TenantID, arg.Permission)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}
