// Code generated by sqlc. DO NOT EDIT.

package db

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

type Queries struct {
	db DBTX
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries {
	return &Queries{db: tx}
}

type ListUsersByEmailRow struct {
	ID           uuid.UUID
	TenantID     uuid.UUID
	Email        string
	FullName     string
	PasswordHash string
	IsActive     bool
	TenantSlug   string
	TenantName   string
}

const listUsersByEmail = `-- name: ListUsersByEmail :many
SELECT
  u.id,
  u.tenant_id,
  u.email,
  u.full_name,
  u.password_hash,
  u.is_active,
  t.slug AS tenant_slug,
  t.name AS tenant_name
FROM users u
JOIN tenants t ON t.id = u.tenant_id
WHERE lower(u.email) = lower($1)
`

func (q *Queries) ListUsersByEmail(ctx context.Context, email string) ([]ListUsersByEmailRow, error) {
	rows, err := q.db.Query(ctx, listUsersByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersByEmailRow{}
	for rows.Next() {
		var i ListUsersByEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Email,
			&i.FullName,
			&i.PasswordHash,
			&i.IsActive,
			&i.TenantSlug,
			&i.TenantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type CreateSessionParams struct {
	TenantID  uuid.UUID
	UserID    uuid.UUID
	TokenHash string
	CsrfToken string
	ExpiresAt time.Time
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
  tenant_id,
  user_id,
  token_hash,
  csrf_token,
  expires_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
RETURNING id, tenant_id, user_id, token_hash, csrf_token, created_at, expires_at, last_seen_at, revoked_at
`

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.TenantID,
		arg.UserID,
		arg.TokenHash,
		arg.CsrfToken,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.TokenHash,
		&i.CsrfToken,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastSeenAt,
		&i.RevokedAt,
	)
	return i, err
}

type GetSessionPrincipalByTokenHashRow struct {
	SessionID  uuid.UUID
	TenantID   uuid.UUID
	UserID     uuid.UUID
	CsrfToken  string
	ExpiresAt  time.Time
	Email      string
	FullName   string
	TenantSlug string
	TenantName string
}

const getSessionPrincipalByTokenHash = `-- name: GetSessionPrincipalByTokenHash :one
SELECT
  s.id AS session_id,
  s.tenant_id,
  s.user_id,
  s.csrf_token,
  s.expires_at,
  u.email,
  u.full_name,
  t.slug AS tenant_slug,
  t.name AS tenant_name
FROM sessions s
JOIN users u ON u.id = s.user_id
JOIN tenants t ON t.id = s.tenant_id
WHERE s.token_hash = $1
  AND s.revoked_at IS NULL
  AND s.expires_at > NOW()
  AND u.is_active = TRUE
`

func (q *Queries) GetSessionPrincipalByTokenHash(ctx context.Context, tokenHash string) (GetSessionPrincipalByTokenHashRow, error) {
	row := q.db.QueryRow(ctx, getSessionPrincipalByTokenHash, tokenHash)
	var i GetSessionPrincipalByTokenHashRow
	err := row.Scan(
		&i.SessionID,
		&i.TenantID,
		&i.UserID,
		&i.CsrfToken,
		&i.ExpiresAt,
		&i.Email,
		&i.FullName,
		&i.TenantSlug,
		&i.TenantName,
	)
	return i, err
}

const touchSession = `-- name: TouchSession :exec
UPDATE sessions
SET last_seen_at = NOW()
WHERE id = $1
`

func (q *Queries) TouchSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, touchSession, id)
	return err
}

type RevokeSessionByIDParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
}

const revokeSessionByID = `-- name: RevokeSessionByID :execrows
UPDATE sessions
SET revoked_at = NOW()
WHERE id = $1
  AND tenant_id = $2
  AND revoked_at IS NULL
`

func (q *Queries) RevokeSessionByID(ctx context.Context, arg RevokeSessionByIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, revokeSessionByID, arg.ID, arg.TenantID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const revokeSessionByTokenHash = `-- name: RevokeSessionByTokenHash :execrows
UPDATE sessions
SET revoked_at = NOW()
WHERE token_hash = $1
  AND revoked_at IS NULL
`

func (q *Queries) RevokeSessionByTokenHash(ctx context.Context, tokenHash string) (int64, error) {
	result, err := q.db.Exec(ctx, revokeSessionByTokenHash, tokenHash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

type UserHasPermissionParams struct {
	UserID     uuid.UUID
	TenantID   uuid.UUID
	Permission string
}

const userHasPermission = `-- name: UserHasPermission :one
SELECT EXISTS (
  SELECT 1
  FROM user_roles ur
  JOIN roles r ON r.id = ur.role_id
  JOIN role_permissions rp ON rp.role_id = r.id
  JOIN permissions p ON p.id = rp.permission_id
  WHERE ur.user_id = $1
    AND ur.tenant_id = $2
    AND r.tenant_id = $2
    AND p.name = $3
) AS has_permission
`

func (q *Queries) UserHasPermission(ctx context.Context, arg UserHasPermissionParams) (bool, error) {
	row := q.db.QueryRow(ctx, userHasPermission, arg.UserID, arg.TenantID, arg.Permission)
	var has bool
	err := row.Scan(&has)
	return has, err
}

type CreateCustomerParams struct {
	TenantID  uuid.UUID
	FirstName string
	LastName  string
	Email     *string
	Phone     *string
	CreatedBy uuid.UUID
	UpdatedBy uuid.UUID
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
  tenant_id,
  first_name,
  last_name,
  email,
  phone,
  created_by,
  updated_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
RETURNING id, tenant_id, first_name, last_name, email, phone, created_by, updated_by, created_at, updated_at
`

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.TenantID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type GetCustomerByIDParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
}

const getCustomerByID = `-- name: GetCustomerByID :one
SELECT
  id,
  tenant_id,
  first_name,
  last_name,
  email,
  phone,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM customers
WHERE id = $1
  AND tenant_id = $2
`

func (q *Queries) GetCustomerByID(ctx context.Context, arg GetCustomerByIDParams) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByID, arg.ID, arg.TenantID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type InsertAuditLogParams struct {
	TenantID   uuid.UUID
	UserID     *uuid.UUID
	Action     string
	EntityType string
	EntityID   *uuid.UUID
	RequestID  *string
	Metadata   []byte
}

const insertAuditLog = `-- name: InsertAuditLog :exec
INSERT INTO audit_log (
  tenant_id,
  user_id,
  action,
  entity_type,
  entity_id,
  request_id,
  metadata
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
`

func (q *Queries) InsertAuditLog(ctx context.Context, arg InsertAuditLogParams) error {
	if !json.Valid(arg.Metadata) {
		return fmt.Errorf("metadata must be valid JSON")
	}
	_, err := q.db.Exec(ctx, insertAuditLog,
		arg.TenantID,
		arg.UserID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.RequestID,
		arg.Metadata,
	)
	return err
}
