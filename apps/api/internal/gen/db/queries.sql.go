// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
  tenant_id,
  first_name,
  last_name,
  email,
  phone,
  created_by,
  updated_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
RETURNING id, tenant_id, first_name, last_name, email, phone, created_by, updated_by, created_at, updated_at
`

type CreateCustomerParams struct {
	TenantID  uuid.UUID  `json:"tenant_id"`
	FirstName string     `json:"first_name"`
	LastName  string     `json:"last_name"`
	Email     *string    `json:"email"`
	Phone     *string    `json:"phone"`
	CreatedBy *uuid.UUID `json:"created_by"`
	UpdatedBy *uuid.UUID `json:"updated_by"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.TenantID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCustomerForEstimate = `-- name: CreateCustomerForEstimate :one
INSERT INTO customers (
  tenant_id,
  first_name,
  last_name,
  email,
  phone,
  created_by,
  updated_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
RETURNING id, tenant_id, first_name, last_name, email, phone, created_by, updated_by, created_at, updated_at
`

type CreateCustomerForEstimateParams struct {
	TenantID  uuid.UUID  `json:"tenant_id"`
	FirstName string     `json:"first_name"`
	LastName  string     `json:"last_name"`
	Email     *string    `json:"email"`
	Phone     *string    `json:"phone"`
	CreatedBy *uuid.UUID `json:"created_by"`
	UpdatedBy *uuid.UUID `json:"updated_by"`
}

func (q *Queries) CreateCustomerForEstimate(ctx context.Context, arg CreateCustomerForEstimateParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomerForEstimate,
		arg.TenantID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEstimate = `-- name: CreateEstimate :one
INSERT INTO estimates (
  tenant_id,
  estimate_number,
  customer_id,
  status,
  customer_name,
  primary_phone,
  secondary_phone,
  email,
  origin_address_line1,
  origin_city,
  origin_state,
  origin_postal_code,
  destination_address_line1,
  destination_city,
  destination_state,
  destination_postal_code,
  move_date,
  pickup_time,
  lead_source,
  move_size,
  location_type,
  estimated_total_cents,
  deposit_cents,
  notes,
  idempotency_key,
  idempotency_payload_hash,
  created_by,
  updated_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  $18,
  $19,
  $20,
  $21,
  $22,
  $23,
  $24,
  $25,
  $26,
  $27,
  $28
)
RETURNING id, tenant_id, estimate_number, customer_id, status, customer_name, primary_phone, secondary_phone, email, origin_address_line1, origin_city, origin_state, origin_postal_code, destination_address_line1, destination_city, destination_state, destination_postal_code, move_date, pickup_time, lead_source, move_size, location_type, estimated_total_cents, deposit_cents, notes, idempotency_key, idempotency_payload_hash, created_by, updated_by, created_at, updated_at
`

type CreateEstimateParams struct {
	TenantID                uuid.UUID  `json:"tenant_id"`
	EstimateNumber          string     `json:"estimate_number"`
	CustomerID              uuid.UUID  `json:"customer_id"`
	Status                  string     `json:"status"`
	CustomerName            string     `json:"customer_name"`
	PrimaryPhone            string     `json:"primary_phone"`
	SecondaryPhone          *string    `json:"secondary_phone"`
	Email                   string     `json:"email"`
	OriginAddressLine1      string     `json:"origin_address_line1"`
	OriginCity              string     `json:"origin_city"`
	OriginState             string     `json:"origin_state"`
	OriginPostalCode        string     `json:"origin_postal_code"`
	DestinationAddressLine1 string     `json:"destination_address_line1"`
	DestinationCity         string     `json:"destination_city"`
	DestinationState        string     `json:"destination_state"`
	DestinationPostalCode   string     `json:"destination_postal_code"`
	MoveDate                time.Time  `json:"move_date"`
	PickupTime              *string    `json:"pickup_time"`
	LeadSource              string     `json:"lead_source"`
	MoveSize                *string    `json:"move_size"`
	LocationType            *string    `json:"location_type"`
	EstimatedTotalCents     *int64     `json:"estimated_total_cents"`
	DepositCents            *int64     `json:"deposit_cents"`
	Notes                   *string    `json:"notes"`
	IdempotencyKey          *string    `json:"idempotency_key"`
	IdempotencyPayloadHash  *string    `json:"idempotency_payload_hash"`
	CreatedBy               *uuid.UUID `json:"created_by"`
	UpdatedBy               *uuid.UUID `json:"updated_by"`
}

func (q *Queries) CreateEstimate(ctx context.Context, arg CreateEstimateParams) (Estimate, error) {
	row := q.db.QueryRow(ctx, createEstimate,
		arg.TenantID,
		arg.EstimateNumber,
		arg.CustomerID,
		arg.Status,
		arg.CustomerName,
		arg.PrimaryPhone,
		arg.SecondaryPhone,
		arg.Email,
		arg.OriginAddressLine1,
		arg.OriginCity,
		arg.OriginState,
		arg.OriginPostalCode,
		arg.DestinationAddressLine1,
		arg.DestinationCity,
		arg.DestinationState,
		arg.DestinationPostalCode,
		arg.MoveDate,
		arg.PickupTime,
		arg.LeadSource,
		arg.MoveSize,
		arg.LocationType,
		arg.EstimatedTotalCents,
		arg.DepositCents,
		arg.Notes,
		arg.IdempotencyKey,
		arg.IdempotencyPayloadHash,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Estimate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EstimateNumber,
		&i.CustomerID,
		&i.Status,
		&i.CustomerName,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.Email,
		&i.OriginAddressLine1,
		&i.OriginCity,
		&i.OriginState,
		&i.OriginPostalCode,
		&i.DestinationAddressLine1,
		&i.DestinationCity,
		&i.DestinationState,
		&i.DestinationPostalCode,
		&i.MoveDate,
		&i.PickupTime,
		&i.LeadSource,
		&i.MoveSize,
		&i.LocationType,
		&i.EstimatedTotalCents,
		&i.DepositCents,
		&i.Notes,
		&i.IdempotencyKey,
		&i.IdempotencyPayloadHash,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
  tenant_id,
  job_number,
  estimate_id,
  customer_id,
  status,
  scheduled_date,
  pickup_time,
  convert_idempotency_key,
  created_by,
  updated_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10
)
RETURNING id, tenant_id, job_number, estimate_id, customer_id, status, scheduled_date, pickup_time, convert_idempotency_key, created_by, updated_by, created_at, updated_at
`

type CreateJobParams struct {
	TenantID              uuid.UUID  `json:"tenant_id"`
	JobNumber             string     `json:"job_number"`
	EstimateID            *uuid.UUID `json:"estimate_id"`
	CustomerID            uuid.UUID  `json:"customer_id"`
	Status                string     `json:"status"`
	ScheduledDate         *time.Time `json:"scheduled_date"`
	PickupTime            *string    `json:"pickup_time"`
	ConvertIdempotencyKey *string    `json:"convert_idempotency_key"`
	CreatedBy             *uuid.UUID `json:"created_by"`
	UpdatedBy             *uuid.UUID `json:"updated_by"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.TenantID,
		arg.JobNumber,
		arg.EstimateID,
		arg.CustomerID,
		arg.Status,
		arg.ScheduledDate,
		arg.PickupTime,
		arg.ConvertIdempotencyKey,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
  tenant_id,
  user_id,
  token_hash,
  csrf_token,
  expires_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
RETURNING id, tenant_id, user_id, token_hash, csrf_token, created_at, expires_at, last_seen_at, revoked_at
`

type CreateSessionParams struct {
	TenantID  uuid.UUID `json:"tenant_id"`
	UserID    uuid.UUID `json:"user_id"`
	TokenHash string    `json:"token_hash"`
	CsrfToken string    `json:"csrf_token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.TenantID,
		arg.UserID,
		arg.TokenHash,
		arg.CsrfToken,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.TokenHash,
		&i.CsrfToken,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastSeenAt,
		&i.RevokedAt,
	)
	return i, err
}

const createStorageRecord = `-- name: CreateStorageRecord :one
INSERT INTO storage_record (
  tenant_id,
  job_id,
  facility,
  status,
  date_in,
  date_out,
  next_bill_date,
  lot_number,
  location_label,
  vaults,
  pads,
  items,
  oversize_items,
  volume,
  monthly_rate_cents,
  storage_balance_cents,
  move_balance_cents,
  last_payment_at,
  notes
) VALUES (
  $1,
  $2,
  $3,
  COALESCE($4::text, 'in_storage'),
  $5::date,
  $6::date,
  $7::date,
  $8,
  $9,
  COALESCE($10::int, 0),
  COALESCE($11::int, 0),
  COALESCE($12::int, 0),
  COALESCE($13::int, 0),
  COALESCE($14::int, 0),
  $15::bigint,
  COALESCE($16::bigint, 0),
  COALESCE($17::bigint, 0),
  $18::timestamptz,
  $19
)
RETURNING id, tenant_id, job_id, facility, status, date_in, date_out, next_bill_date, lot_number, location_label, vaults, pads, items, oversize_items, volume, monthly_rate_cents, storage_balance_cents, move_balance_cents, last_payment_at, notes, created_at, updated_at
`

type CreateStorageRecordParams struct {
	TenantID            uuid.UUID  `json:"tenant_id"`
	JobID               uuid.UUID  `json:"job_id"`
	Facility            string     `json:"facility"`
	Status              *string    `json:"status"`
	DateIn              *time.Time `json:"date_in"`
	DateOut             *time.Time `json:"date_out"`
	NextBillDate        *time.Time `json:"next_bill_date"`
	LotNumber           *string    `json:"lot_number"`
	LocationLabel       *string    `json:"location_label"`
	Vaults              *int32     `json:"vaults"`
	Pads                *int32     `json:"pads"`
	Items               *int32     `json:"items"`
	OversizeItems       *int32     `json:"oversize_items"`
	Volume              *int32     `json:"volume"`
	MonthlyRateCents    *int64     `json:"monthly_rate_cents"`
	StorageBalanceCents *int64     `json:"storage_balance_cents"`
	MoveBalanceCents    *int64     `json:"move_balance_cents"`
	LastPaymentAt       *time.Time `json:"last_payment_at"`
	Notes               *string    `json:"notes"`
}

func (q *Queries) CreateStorageRecord(ctx context.Context, arg CreateStorageRecordParams) (StorageRecord, error) {
	row := q.db.QueryRow(ctx, createStorageRecord,
		arg.TenantID,
		arg.JobID,
		arg.Facility,
		arg.Status,
		arg.DateIn,
		arg.DateOut,
		arg.NextBillDate,
		arg.LotNumber,
		arg.LocationLabel,
		arg.Vaults,
		arg.Pads,
		arg.Items,
		arg.OversizeItems,
		arg.Volume,
		arg.MonthlyRateCents,
		arg.StorageBalanceCents,
		arg.MoveBalanceCents,
		arg.LastPaymentAt,
		arg.Notes,
	)
	var i StorageRecord
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobID,
		&i.Facility,
		&i.Status,
		&i.DateIn,
		&i.DateOut,
		&i.NextBillDate,
		&i.LotNumber,
		&i.LocationLabel,
		&i.Vaults,
		&i.Pads,
		&i.Items,
		&i.OversizeItems,
		&i.Volume,
		&i.MonthlyRateCents,
		&i.StorageBalanceCents,
		&i.MoveBalanceCents,
		&i.LastPaymentAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerByID = `-- name: GetCustomerByID :one
SELECT
  id,
  tenant_id,
  first_name,
  last_name,
  email,
  phone,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM customers
WHERE id = $1
  AND tenant_id = $2
`

type GetCustomerByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetCustomerByID(ctx context.Context, arg GetCustomerByIDParams) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByID, arg.ID, arg.TenantID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEstimateByID = `-- name: GetEstimateByID :one
SELECT
  id,
  tenant_id,
  estimate_number,
  customer_id,
  status,
  customer_name,
  primary_phone,
  secondary_phone,
  email,
  origin_address_line1,
  origin_city,
  origin_state,
  origin_postal_code,
  destination_address_line1,
  destination_city,
  destination_state,
  destination_postal_code,
  move_date,
  pickup_time,
  lead_source,
  move_size,
  location_type,
  estimated_total_cents,
  deposit_cents,
  notes,
  idempotency_key,
  idempotency_payload_hash,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM estimates
WHERE id = $1
  AND tenant_id = $2
`

type GetEstimateByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetEstimateByID(ctx context.Context, arg GetEstimateByIDParams) (Estimate, error) {
	row := q.db.QueryRow(ctx, getEstimateByID, arg.ID, arg.TenantID)
	var i Estimate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EstimateNumber,
		&i.CustomerID,
		&i.Status,
		&i.CustomerName,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.Email,
		&i.OriginAddressLine1,
		&i.OriginCity,
		&i.OriginState,
		&i.OriginPostalCode,
		&i.DestinationAddressLine1,
		&i.DestinationCity,
		&i.DestinationState,
		&i.DestinationPostalCode,
		&i.MoveDate,
		&i.PickupTime,
		&i.LeadSource,
		&i.MoveSize,
		&i.LocationType,
		&i.EstimatedTotalCents,
		&i.DepositCents,
		&i.Notes,
		&i.IdempotencyKey,
		&i.IdempotencyPayloadHash,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEstimateByIdempotencyKey = `-- name: GetEstimateByIdempotencyKey :one
SELECT
  id,
  tenant_id,
  estimate_number,
  customer_id,
  status,
  customer_name,
  primary_phone,
  secondary_phone,
  email,
  origin_address_line1,
  origin_city,
  origin_state,
  origin_postal_code,
  destination_address_line1,
  destination_city,
  destination_state,
  destination_postal_code,
  move_date,
  pickup_time,
  lead_source,
  move_size,
  location_type,
  estimated_total_cents,
  deposit_cents,
  notes,
  idempotency_key,
  idempotency_payload_hash,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM estimates
WHERE tenant_id = $1
  AND idempotency_key = $2
`

type GetEstimateByIdempotencyKeyParams struct {
	TenantID       uuid.UUID `json:"tenant_id"`
	IdempotencyKey *string   `json:"idempotency_key"`
}

func (q *Queries) GetEstimateByIdempotencyKey(ctx context.Context, arg GetEstimateByIdempotencyKeyParams) (Estimate, error) {
	row := q.db.QueryRow(ctx, getEstimateByIdempotencyKey, arg.TenantID, arg.IdempotencyKey)
	var i Estimate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EstimateNumber,
		&i.CustomerID,
		&i.Status,
		&i.CustomerName,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.Email,
		&i.OriginAddressLine1,
		&i.OriginCity,
		&i.OriginState,
		&i.OriginPostalCode,
		&i.DestinationAddressLine1,
		&i.DestinationCity,
		&i.DestinationState,
		&i.DestinationPostalCode,
		&i.MoveDate,
		&i.PickupTime,
		&i.LeadSource,
		&i.MoveSize,
		&i.LocationType,
		&i.EstimatedTotalCents,
		&i.DepositCents,
		&i.Notes,
		&i.IdempotencyKey,
		&i.IdempotencyPayloadHash,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEstimateDetailByID = `-- name: GetEstimateDetailByID :one
SELECT
  e.id,
  e.tenant_id,
  e.estimate_number,
  e.customer_id,
  e.status,
  e.customer_name,
  e.primary_phone,
  e.secondary_phone,
  e.email,
  e.origin_address_line1,
  e.origin_city,
  e.origin_state,
  e.origin_postal_code,
  e.destination_address_line1,
  e.destination_city,
  e.destination_state,
  e.destination_postal_code,
  e.move_date,
  e.pickup_time,
  e.lead_source,
  e.move_size,
  e.location_type,
  e.estimated_total_cents,
  e.deposit_cents,
  e.notes,
  e.idempotency_key,
  e.idempotency_payload_hash,
  e.created_by,
  e.updated_by,
  e.created_at,
  e.updated_at,
  j.id AS converted_job_id
FROM estimates e
LEFT JOIN jobs j
  ON j.tenant_id = e.tenant_id
  AND j.estimate_id = e.id
WHERE e.id = $1
  AND e.tenant_id = $2
`

type GetEstimateDetailByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

type GetEstimateDetailByIDRow struct {
	ID                      uuid.UUID  `json:"id"`
	TenantID                uuid.UUID  `json:"tenant_id"`
	EstimateNumber          string     `json:"estimate_number"`
	CustomerID              uuid.UUID  `json:"customer_id"`
	Status                  string     `json:"status"`
	CustomerName            string     `json:"customer_name"`
	PrimaryPhone            string     `json:"primary_phone"`
	SecondaryPhone          *string    `json:"secondary_phone"`
	Email                   string     `json:"email"`
	OriginAddressLine1      string     `json:"origin_address_line1"`
	OriginCity              string     `json:"origin_city"`
	OriginState             string     `json:"origin_state"`
	OriginPostalCode        string     `json:"origin_postal_code"`
	DestinationAddressLine1 string     `json:"destination_address_line1"`
	DestinationCity         string     `json:"destination_city"`
	DestinationState        string     `json:"destination_state"`
	DestinationPostalCode   string     `json:"destination_postal_code"`
	MoveDate                time.Time  `json:"move_date"`
	PickupTime              *string    `json:"pickup_time"`
	LeadSource              string     `json:"lead_source"`
	MoveSize                *string    `json:"move_size"`
	LocationType            *string    `json:"location_type"`
	EstimatedTotalCents     *int64     `json:"estimated_total_cents"`
	DepositCents            *int64     `json:"deposit_cents"`
	Notes                   *string    `json:"notes"`
	IdempotencyKey          *string    `json:"idempotency_key"`
	IdempotencyPayloadHash  *string    `json:"idempotency_payload_hash"`
	CreatedBy               *uuid.UUID `json:"created_by"`
	UpdatedBy               *uuid.UUID `json:"updated_by"`
	CreatedAt               time.Time  `json:"created_at"`
	UpdatedAt               time.Time  `json:"updated_at"`
	ConvertedJobID          *uuid.UUID `json:"converted_job_id"`
}

func (q *Queries) GetEstimateDetailByID(ctx context.Context, arg GetEstimateDetailByIDParams) (GetEstimateDetailByIDRow, error) {
	row := q.db.QueryRow(ctx, getEstimateDetailByID, arg.ID, arg.TenantID)
	var i GetEstimateDetailByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EstimateNumber,
		&i.CustomerID,
		&i.Status,
		&i.CustomerName,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.Email,
		&i.OriginAddressLine1,
		&i.OriginCity,
		&i.OriginState,
		&i.OriginPostalCode,
		&i.DestinationAddressLine1,
		&i.DestinationCity,
		&i.DestinationState,
		&i.DestinationPostalCode,
		&i.MoveDate,
		&i.PickupTime,
		&i.LeadSource,
		&i.MoveSize,
		&i.LocationType,
		&i.EstimatedTotalCents,
		&i.DepositCents,
		&i.Notes,
		&i.IdempotencyKey,
		&i.IdempotencyPayloadHash,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConvertedJobID,
	)
	return i, err
}

const getJobByConvertIdempotencyKey = `-- name: GetJobByConvertIdempotencyKey :one
SELECT
  id,
  tenant_id,
  job_number,
  estimate_id,
  customer_id,
  status,
  scheduled_date,
  pickup_time,
  convert_idempotency_key,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM jobs
WHERE tenant_id = $1
  AND convert_idempotency_key = $2
`

type GetJobByConvertIdempotencyKeyParams struct {
	TenantID              uuid.UUID `json:"tenant_id"`
	ConvertIdempotencyKey *string   `json:"convert_idempotency_key"`
}

func (q *Queries) GetJobByConvertIdempotencyKey(ctx context.Context, arg GetJobByConvertIdempotencyKeyParams) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByConvertIdempotencyKey, arg.TenantID, arg.ConvertIdempotencyKey)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobByEstimateID = `-- name: GetJobByEstimateID :one
SELECT
  id,
  tenant_id,
  job_number,
  estimate_id,
  customer_id,
  status,
  scheduled_date,
  pickup_time,
  convert_idempotency_key,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM jobs
WHERE tenant_id = $1
  AND estimate_id = $2
`

type GetJobByEstimateIDParams struct {
	TenantID   uuid.UUID  `json:"tenant_id"`
	EstimateID *uuid.UUID `json:"estimate_id"`
}

func (q *Queries) GetJobByEstimateID(ctx context.Context, arg GetJobByEstimateIDParams) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByEstimateID, arg.TenantID, arg.EstimateID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobByID = `-- name: GetJobByID :one
SELECT
  id,
  tenant_id,
  job_number,
  estimate_id,
  customer_id,
  status,
  scheduled_date,
  pickup_time,
  convert_idempotency_key,
  created_by,
  updated_by,
  created_at,
  updated_at
FROM jobs
WHERE id = $1
  AND tenant_id = $2
`

type GetJobByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetJobByID(ctx context.Context, arg GetJobByIDParams) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByID, arg.ID, arg.TenantID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobDetailByID = `-- name: GetJobDetailByID :one
SELECT
  j.id,
  j.tenant_id,
  j.job_number,
  j.estimate_id,
  j.customer_id,
  j.status,
  j.scheduled_date,
  j.pickup_time,
  j.convert_idempotency_key,
  j.created_by,
  j.updated_by,
  j.created_at,
  j.updated_at,
  c.first_name,
  c.last_name,
  COALESCE(c.phone, e.primary_phone, '') AS phone,
  COALESCE(c.email, e.email, 'no-reply@moveops.local') AS email
FROM jobs j
JOIN customers c
  ON c.id = j.customer_id
  AND c.tenant_id = j.tenant_id
LEFT JOIN estimates e
  ON e.id = j.estimate_id
  AND e.tenant_id = j.tenant_id
WHERE j.id = $1
  AND j.tenant_id = $2
`

type GetJobDetailByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

type GetJobDetailByIDRow struct {
	ID                    uuid.UUID  `json:"id"`
	TenantID              uuid.UUID  `json:"tenant_id"`
	JobNumber             string     `json:"job_number"`
	EstimateID            *uuid.UUID `json:"estimate_id"`
	CustomerID            uuid.UUID  `json:"customer_id"`
	Status                string     `json:"status"`
	ScheduledDate         *time.Time `json:"scheduled_date"`
	PickupTime            *string    `json:"pickup_time"`
	ConvertIdempotencyKey *string    `json:"convert_idempotency_key"`
	CreatedBy             *uuid.UUID `json:"created_by"`
	UpdatedBy             *uuid.UUID `json:"updated_by"`
	CreatedAt             time.Time  `json:"created_at"`
	UpdatedAt             time.Time  `json:"updated_at"`
	FirstName             string     `json:"first_name"`
	LastName              string     `json:"last_name"`
	Phone                 string     `json:"phone"`
	Email                 string     `json:"email"`
}

func (q *Queries) GetJobDetailByID(ctx context.Context, arg GetJobDetailByIDParams) (GetJobDetailByIDRow, error) {
	row := q.db.QueryRow(ctx, getJobDetailByID, arg.ID, arg.TenantID)
	var i GetJobDetailByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Email,
	)
	return i, err
}

const getSessionPrincipalByTokenHash = `-- name: GetSessionPrincipalByTokenHash :one
SELECT
  s.id AS session_id,
  s.tenant_id,
  s.user_id,
  s.csrf_token,
  s.expires_at,
  u.email,
  u.full_name,
  t.slug AS tenant_slug,
  t.name AS tenant_name
FROM sessions s
JOIN users u ON u.id = s.user_id
JOIN tenants t ON t.id = s.tenant_id
WHERE s.token_hash = $1
  AND s.revoked_at IS NULL
  AND s.expires_at > NOW()
  AND u.is_active = TRUE
`

type GetSessionPrincipalByTokenHashRow struct {
	SessionID  uuid.UUID `json:"session_id"`
	TenantID   uuid.UUID `json:"tenant_id"`
	UserID     uuid.UUID `json:"user_id"`
	CsrfToken  string    `json:"csrf_token"`
	ExpiresAt  time.Time `json:"expires_at"`
	Email      string    `json:"email"`
	FullName   string    `json:"full_name"`
	TenantSlug string    `json:"tenant_slug"`
	TenantName string    `json:"tenant_name"`
}

func (q *Queries) GetSessionPrincipalByTokenHash(ctx context.Context, tokenHash string) (GetSessionPrincipalByTokenHashRow, error) {
	row := q.db.QueryRow(ctx, getSessionPrincipalByTokenHash, tokenHash)
	var i GetSessionPrincipalByTokenHashRow
	err := row.Scan(
		&i.SessionID,
		&i.TenantID,
		&i.UserID,
		&i.CsrfToken,
		&i.ExpiresAt,
		&i.Email,
		&i.FullName,
		&i.TenantSlug,
		&i.TenantName,
	)
	return i, err
}

const getStorageRecordByID = `-- name: GetStorageRecordByID :one
SELECT
  id,
  tenant_id,
  job_id,
  facility,
  status,
  date_in,
  date_out,
  next_bill_date,
  lot_number,
  location_label,
  vaults,
  pads,
  items,
  oversize_items,
  volume,
  monthly_rate_cents,
  storage_balance_cents,
  move_balance_cents,
  last_payment_at,
  notes,
  created_at,
  updated_at
FROM storage_record
WHERE id = $1
  AND tenant_id = $2
`

type GetStorageRecordByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetStorageRecordByID(ctx context.Context, arg GetStorageRecordByIDParams) (StorageRecord, error) {
	row := q.db.QueryRow(ctx, getStorageRecordByID, arg.ID, arg.TenantID)
	var i StorageRecord
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobID,
		&i.Facility,
		&i.Status,
		&i.DateIn,
		&i.DateOut,
		&i.NextBillDate,
		&i.LotNumber,
		&i.LocationLabel,
		&i.Vaults,
		&i.Pads,
		&i.Items,
		&i.OversizeItems,
		&i.Volume,
		&i.MonthlyRateCents,
		&i.StorageBalanceCents,
		&i.MoveBalanceCents,
		&i.LastPaymentAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStorageRecordByJobID = `-- name: GetStorageRecordByJobID :one
SELECT
  id,
  tenant_id,
  job_id,
  facility,
  status,
  date_in,
  date_out,
  next_bill_date,
  lot_number,
  location_label,
  vaults,
  pads,
  items,
  oversize_items,
  volume,
  monthly_rate_cents,
  storage_balance_cents,
  move_balance_cents,
  last_payment_at,
  notes,
  created_at,
  updated_at
FROM storage_record
WHERE job_id = $1
  AND tenant_id = $2
`

type GetStorageRecordByJobIDParams struct {
	JobID    uuid.UUID `json:"job_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetStorageRecordByJobID(ctx context.Context, arg GetStorageRecordByJobIDParams) (StorageRecord, error) {
	row := q.db.QueryRow(ctx, getStorageRecordByJobID, arg.JobID, arg.TenantID)
	var i StorageRecord
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobID,
		&i.Facility,
		&i.Status,
		&i.DateIn,
		&i.DateOut,
		&i.NextBillDate,
		&i.LotNumber,
		&i.LocationLabel,
		&i.Vaults,
		&i.Pads,
		&i.Items,
		&i.OversizeItems,
		&i.Volume,
		&i.MonthlyRateCents,
		&i.StorageBalanceCents,
		&i.MoveBalanceCents,
		&i.LastPaymentAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStorageRecordDetailByID = `-- name: GetStorageRecordDetailByID :one
SELECT
  sr.id,
  sr.tenant_id,
  sr.job_id,
  j.job_number,
  COALESCE(NULLIF(TRIM(c.first_name || ' ' || c.last_name), ''), COALESCE(e.customer_name, j.job_number))::text AS customer_name,
  CASE
    WHEN e.id IS NULL THEN 'other'
    WHEN NULLIF(TRIM(COALESCE(e.origin_state, '')), '') IS NULL THEN 'other'
    WHEN NULLIF(TRIM(COALESCE(e.destination_state, '')), '') IS NULL THEN 'other'
    WHEN UPPER(e.origin_state) = UPPER(e.destination_state) THEN 'local'
    ELSE 'long_distance'
  END::text AS move_type,
  COALESCE(
    NULLIF(CONCAT_WS(', ', NULLIF(TRIM(e.origin_city), ''), NULLIF(TRIM(e.origin_state), '')), ''),
    'TBD'
  )::text AS from_short,
  COALESCE(
    NULLIF(CONCAT_WS(', ', NULLIF(TRIM(e.destination_city), ''), NULLIF(TRIM(e.destination_state), '')), ''),
    'TBD'
  )::text AS to_short,
  sr.facility,
  sr.status,
  sr.date_in,
  sr.date_out,
  sr.next_bill_date,
  sr.lot_number,
  sr.location_label,
  sr.vaults,
  sr.pads,
  sr.items,
  sr.oversize_items,
  sr.volume,
  sr.monthly_rate_cents,
  sr.storage_balance_cents,
  sr.move_balance_cents,
  sr.last_payment_at,
  sr.notes,
  sr.created_at,
  sr.updated_at
FROM storage_record sr
JOIN jobs j
  ON j.id = sr.job_id
  AND j.tenant_id = sr.tenant_id
JOIN customers c
  ON c.id = j.customer_id
  AND c.tenant_id = j.tenant_id
LEFT JOIN estimates e
  ON e.id = j.estimate_id
  AND e.tenant_id = j.tenant_id
WHERE sr.id = $1
  AND sr.tenant_id = $2
`

type GetStorageRecordDetailByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

type GetStorageRecordDetailByIDRow struct {
	ID                  uuid.UUID  `json:"id"`
	TenantID            uuid.UUID  `json:"tenant_id"`
	JobID               uuid.UUID  `json:"job_id"`
	JobNumber           string     `json:"job_number"`
	CustomerName        string     `json:"customer_name"`
	MoveType            string     `json:"move_type"`
	FromShort           string     `json:"from_short"`
	ToShort             string     `json:"to_short"`
	Facility            string     `json:"facility"`
	Status              string     `json:"status"`
	DateIn              *time.Time `json:"date_in"`
	DateOut             *time.Time `json:"date_out"`
	NextBillDate        *time.Time `json:"next_bill_date"`
	LotNumber           *string    `json:"lot_number"`
	LocationLabel       *string    `json:"location_label"`
	Vaults              int32      `json:"vaults"`
	Pads                int32      `json:"pads"`
	Items               int32      `json:"items"`
	OversizeItems       int32      `json:"oversize_items"`
	Volume              int32      `json:"volume"`
	MonthlyRateCents    *int64     `json:"monthly_rate_cents"`
	StorageBalanceCents int64      `json:"storage_balance_cents"`
	MoveBalanceCents    int64      `json:"move_balance_cents"`
	LastPaymentAt       *time.Time `json:"last_payment_at"`
	Notes               *string    `json:"notes"`
	CreatedAt           time.Time  `json:"created_at"`
	UpdatedAt           time.Time  `json:"updated_at"`
}

func (q *Queries) GetStorageRecordDetailByID(ctx context.Context, arg GetStorageRecordDetailByIDParams) (GetStorageRecordDetailByIDRow, error) {
	row := q.db.QueryRow(ctx, getStorageRecordDetailByID, arg.ID, arg.TenantID)
	var i GetStorageRecordDetailByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobID,
		&i.JobNumber,
		&i.CustomerName,
		&i.MoveType,
		&i.FromShort,
		&i.ToShort,
		&i.Facility,
		&i.Status,
		&i.DateIn,
		&i.DateOut,
		&i.NextBillDate,
		&i.LotNumber,
		&i.LocationLabel,
		&i.Vaults,
		&i.Pads,
		&i.Items,
		&i.OversizeItems,
		&i.Volume,
		&i.MonthlyRateCents,
		&i.StorageBalanceCents,
		&i.MoveBalanceCents,
		&i.LastPaymentAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementTenantCounter = `-- name: IncrementTenantCounter :one
INSERT INTO tenant_counters (tenant_id, counter_type, next_value)
VALUES ($1, $2, 2)
ON CONFLICT (tenant_id, counter_type) DO UPDATE
SET
  next_value = tenant_counters.next_value + 1,
  updated_at = NOW()
RETURNING (next_value - 1)::bigint AS value
`

type IncrementTenantCounterParams struct {
	TenantID    uuid.UUID `json:"tenant_id"`
	CounterType string    `json:"counter_type"`
}

func (q *Queries) IncrementTenantCounter(ctx context.Context, arg IncrementTenantCounterParams) (int64, error) {
	row := q.db.QueryRow(ctx, incrementTenantCounter, arg.TenantID, arg.CounterType)
	var value int64
	err := row.Scan(&value)
	return value, err
}

const insertAuditLog = `-- name: InsertAuditLog :exec
INSERT INTO audit_log (
  tenant_id,
  user_id,
  action,
  entity_type,
  entity_id,
  request_id,
  metadata
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
`

type InsertAuditLogParams struct {
	TenantID   uuid.UUID  `json:"tenant_id"`
	UserID     *uuid.UUID `json:"user_id"`
	Action     string     `json:"action"`
	EntityType string     `json:"entity_type"`
	EntityID   *uuid.UUID `json:"entity_id"`
	RequestID  *string    `json:"request_id"`
	Metadata   []byte     `json:"metadata"`
}

func (q *Queries) InsertAuditLog(ctx context.Context, arg InsertAuditLogParams) error {
	_, err := q.db.Exec(ctx, insertAuditLog,
		arg.TenantID,
		arg.UserID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.RequestID,
		arg.Metadata,
	)
	return err
}

const listCalendarJobs = `-- name: ListCalendarJobs :many
SELECT
  j.id AS job_id,
  j.job_number,
  j.scheduled_date,
  j.pickup_time,
  COALESCE(NULLIF(TRIM(c.first_name || ' ' || c.last_name), ''), j.job_number) AS customer_name,
  COALESCE(
    NULLIF(CONCAT_WS(', ', NULLIF(TRIM(e.origin_city), ''), NULLIF(TRIM(e.origin_state), '')), ''),
    'TBD'
  )::text AS origin_short,
  COALESCE(
    NULLIF(CONCAT_WS(', ', NULLIF(TRIM(e.destination_city), ''), NULLIF(TRIM(e.destination_state), '')), ''),
    'TBD'
  )::text AS destination_short,
  j.status,
  FALSE AS has_storage,
  GREATEST(COALESCE(e.estimated_total_cents, 0) - COALESCE(e.deposit_cents, 0), 0)::bigint AS balance_due_cents
FROM jobs j
JOIN customers c
  ON c.id = j.customer_id
  AND c.tenant_id = j.tenant_id
LEFT JOIN estimates e
  ON e.id = j.estimate_id
  AND e.tenant_id = j.tenant_id
WHERE j.tenant_id = $1
  AND j.scheduled_date IS NOT NULL
  AND j.scheduled_date >= $2::date
  AND j.scheduled_date < $3::date
  AND ($4::text IS NULL OR j.status = $4::text)
  AND (
    $5::text IS NULL
    OR (
      CASE
        WHEN e.id IS NULL THEN 'other'
        WHEN NULLIF(TRIM(COALESCE(e.origin_state, '')), '') IS NULL THEN 'other'
        WHEN NULLIF(TRIM(COALESCE(e.destination_state, '')), '') IS NULL THEN 'other'
        WHEN UPPER(e.origin_state) = UPPER(e.destination_state) THEN 'local'
        ELSE 'long_distance'
      END
    ) = $5::text
  )
ORDER BY j.scheduled_date ASC, COALESCE(j.pickup_time, ''), j.job_number ASC
`

type ListCalendarJobsParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
	Phase    *string   `json:"phase"`
	JobType  *string   `json:"job_type"`
}

type ListCalendarJobsRow struct {
	JobID            uuid.UUID  `json:"job_id"`
	JobNumber        string     `json:"job_number"`
	ScheduledDate    *time.Time `json:"scheduled_date"`
	PickupTime       *string    `json:"pickup_time"`
	CustomerName     string     `json:"customer_name"`
	OriginShort      string     `json:"origin_short"`
	DestinationShort string     `json:"destination_short"`
	Status           string     `json:"status"`
	HasStorage       bool       `json:"has_storage"`
	BalanceDueCents  int64      `json:"balance_due_cents"`
}

func (q *Queries) ListCalendarJobs(ctx context.Context, arg ListCalendarJobsParams) ([]ListCalendarJobsRow, error) {
	rows, err := q.db.Query(ctx, listCalendarJobs,
		arg.TenantID,
		arg.FromDate,
		arg.ToDate,
		arg.Phase,
		arg.JobType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCalendarJobsRow{}
	for rows.Next() {
		var i ListCalendarJobsRow
		if err := rows.Scan(
			&i.JobID,
			&i.JobNumber,
			&i.ScheduledDate,
			&i.PickupTime,
			&i.CustomerName,
			&i.OriginShort,
			&i.DestinationShort,
			&i.Status,
			&i.HasStorage,
			&i.BalanceDueCents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStorageRows = `-- name: ListStorageRows :many
SELECT
  sr.id AS storage_record_id,
  j.id AS job_id,
  j.job_number,
  COALESCE(NULLIF(TRIM(c.first_name || ' ' || c.last_name), ''), COALESCE(e.customer_name, j.job_number))::text AS customer_name,
  CASE
    WHEN e.id IS NULL THEN 'other'
    WHEN NULLIF(TRIM(COALESCE(e.origin_state, '')), '') IS NULL THEN 'other'
    WHEN NULLIF(TRIM(COALESCE(e.destination_state, '')), '') IS NULL THEN 'other'
    WHEN UPPER(e.origin_state) = UPPER(e.destination_state) THEN 'local'
    ELSE 'long_distance'
  END::text AS move_type,
  COALESCE(
    NULLIF(CONCAT_WS(', ', NULLIF(TRIM(e.origin_city), ''), NULLIF(TRIM(e.origin_state), '')), ''),
    'TBD'
  )::text AS from_short,
  COALESCE(
    NULLIF(CONCAT_WS(', ', NULLIF(TRIM(e.destination_city), ''), NULLIF(TRIM(e.destination_state), '')), ''),
    'TBD'
  )::text AS to_short,
  sr.status,
  sr.date_in,
  sr.date_out,
  sr.next_bill_date,
  sr.lot_number,
  sr.location_label,
  COALESCE(sr.vaults, 0)::int AS vaults,
  COALESCE(sr.pads, 0)::int AS pads,
  COALESCE(sr.items, 0)::int AS items,
  COALESCE(sr.oversize_items, 0)::int AS oversize_items,
  COALESCE(sr.volume, 0)::int AS volume,
  sr.monthly_rate_cents,
  COALESCE(sr.storage_balance_cents, 0)::bigint AS storage_balance_cents,
  COALESCE(sr.move_balance_cents, 0)::bigint AS move_balance_cents,
  COALESCE(sr.facility, $1)::text AS facility,
  COALESCE(sr.updated_at, j.updated_at) AS sort_updated_at,
  j.id AS sort_job_id
FROM jobs j
JOIN customers c
  ON c.id = j.customer_id
  AND c.tenant_id = j.tenant_id
LEFT JOIN estimates e
  ON e.id = j.estimate_id
  AND e.tenant_id = j.tenant_id
LEFT JOIN storage_record sr
  ON sr.job_id = j.id
  AND sr.tenant_id = j.tenant_id
WHERE j.tenant_id = $2
  AND (sr.id IS NULL OR sr.facility = $1)
  AND (
    $3::text IS NULL
    OR j.job_number ILIKE '%' || $3::text || '%'
    OR COALESCE(NULLIF(TRIM(c.first_name || ' ' || c.last_name), ''), COALESCE(e.customer_name, '')) ILIKE '%' || $3::text || '%'
  )
  AND ($4::text IS NULL OR sr.status = $4::text)
  AND (
    $5::boolean IS NULL
    OR ($5::boolean = TRUE AND sr.date_out IS NOT NULL)
    OR ($5::boolean = FALSE AND sr.date_out IS NULL)
  )
  AND (
    $6::boolean IS NULL
    OR ($6::boolean = TRUE AND COALESCE(sr.storage_balance_cents, 0) > 0)
    OR ($6::boolean = FALSE AND COALESCE(sr.storage_balance_cents, 0) <= 0)
  )
  AND (
    $7::boolean IS NULL
    OR (
      $7::boolean = TRUE
      AND (
        COALESCE(sr.vaults, 0) > 0
        OR COALESCE(sr.pads, 0) > 0
        OR COALESCE(sr.items, 0) > 0
        OR COALESCE(sr.oversize_items, 0) > 0
      )
    )
    OR (
      $7::boolean = FALSE
      AND COALESCE(sr.vaults, 0) = 0
      AND COALESCE(sr.pads, 0) = 0
      AND COALESCE(sr.items, 0) = 0
      AND COALESCE(sr.oversize_items, 0) = 0
    )
  )
  AND (
    $8::int IS NULL
    OR (
      sr.last_payment_at IS NOT NULL
      AND sr.last_payment_at <= NOW() - make_interval(days => $8::int)
    )
  )
  AND (
    $9::timestamptz IS NULL
    OR (
      COALESCE(sr.updated_at, j.updated_at) < $9::timestamptz
      OR (
        COALESCE(sr.updated_at, j.updated_at) = $9::timestamptz
        AND j.id < $10::uuid
      )
    )
  )
ORDER BY COALESCE(sr.updated_at, j.updated_at) DESC, j.id DESC
LIMIT $11
`

type ListStorageRowsParams struct {
	Facility        string     `json:"facility"`
	TenantID        uuid.UUID  `json:"tenant_id"`
	SearchQ         *string    `json:"search_q"`
	Status          *string    `json:"status"`
	HasDateOut      *bool      `json:"has_date_out"`
	BalanceDue      *bool      `json:"balance_due"`
	HasContainers   *bool      `json:"has_containers"`
	PastDueDays     *int32     `json:"past_due_days"`
	CursorUpdatedAt *time.Time `json:"cursor_updated_at"`
	CursorJobID     *uuid.UUID `json:"cursor_job_id"`
	LimitRows       int32      `json:"limit_rows"`
}

type ListStorageRowsRow struct {
	StorageRecordID     *uuid.UUID `json:"storage_record_id"`
	JobID               uuid.UUID  `json:"job_id"`
	JobNumber           string     `json:"job_number"`
	CustomerName        string     `json:"customer_name"`
	MoveType            string     `json:"move_type"`
	FromShort           string     `json:"from_short"`
	ToShort             string     `json:"to_short"`
	Status              *string    `json:"status"`
	DateIn              *time.Time `json:"date_in"`
	DateOut             *time.Time `json:"date_out"`
	NextBillDate        *time.Time `json:"next_bill_date"`
	LotNumber           *string    `json:"lot_number"`
	LocationLabel       *string    `json:"location_label"`
	Vaults              int32      `json:"vaults"`
	Pads                int32      `json:"pads"`
	Items               int32      `json:"items"`
	OversizeItems       int32      `json:"oversize_items"`
	Volume              int32      `json:"volume"`
	MonthlyRateCents    *int64     `json:"monthly_rate_cents"`
	StorageBalanceCents int64      `json:"storage_balance_cents"`
	MoveBalanceCents    int64      `json:"move_balance_cents"`
	Facility            string     `json:"facility"`
	SortUpdatedAt       time.Time  `json:"sort_updated_at"`
	SortJobID           uuid.UUID  `json:"sort_job_id"`
}

func (q *Queries) ListStorageRows(ctx context.Context, arg ListStorageRowsParams) ([]ListStorageRowsRow, error) {
	rows, err := q.db.Query(ctx, listStorageRows,
		arg.Facility,
		arg.TenantID,
		arg.SearchQ,
		arg.Status,
		arg.HasDateOut,
		arg.BalanceDue,
		arg.HasContainers,
		arg.PastDueDays,
		arg.CursorUpdatedAt,
		arg.CursorJobID,
		arg.LimitRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStorageRowsRow{}
	for rows.Next() {
		var i ListStorageRowsRow
		if err := rows.Scan(
			&i.StorageRecordID,
			&i.JobID,
			&i.JobNumber,
			&i.CustomerName,
			&i.MoveType,
			&i.FromShort,
			&i.ToShort,
			&i.Status,
			&i.DateIn,
			&i.DateOut,
			&i.NextBillDate,
			&i.LotNumber,
			&i.LocationLabel,
			&i.Vaults,
			&i.Pads,
			&i.Items,
			&i.OversizeItems,
			&i.Volume,
			&i.MonthlyRateCents,
			&i.StorageBalanceCents,
			&i.MoveBalanceCents,
			&i.Facility,
			&i.SortUpdatedAt,
			&i.SortJobID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByEmail = `-- name: ListUsersByEmail :many
SELECT
  u.id,
  u.tenant_id,
  u.email,
  u.full_name,
  u.password_hash,
  u.is_active,
  t.slug AS tenant_slug,
  t.name AS tenant_name
FROM users u
JOIN tenants t ON t.id = u.tenant_id
WHERE lower(u.email) = lower($1)
`

type ListUsersByEmailRow struct {
	ID           uuid.UUID `json:"id"`
	TenantID     uuid.UUID `json:"tenant_id"`
	Email        string    `json:"email"`
	FullName     string    `json:"full_name"`
	PasswordHash string    `json:"password_hash"`
	IsActive     bool      `json:"is_active"`
	TenantSlug   string    `json:"tenant_slug"`
	TenantName   string    `json:"tenant_name"`
}

func (q *Queries) ListUsersByEmail(ctx context.Context, email string) ([]ListUsersByEmailRow, error) {
	rows, err := q.db.Query(ctx, listUsersByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersByEmailRow{}
	for rows.Next() {
		var i ListUsersByEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Email,
			&i.FullName,
			&i.PasswordHash,
			&i.IsActive,
			&i.TenantSlug,
			&i.TenantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEstimateConverted = `-- name: MarkEstimateConverted :execrows
UPDATE estimates
SET
  status = 'converted',
  updated_by = $1,
  updated_at = NOW()
WHERE id = $2
  AND tenant_id = $3
  AND status <> 'converted'
`

type MarkEstimateConvertedParams struct {
	UpdatedBy *uuid.UUID `json:"updated_by"`
	ID        uuid.UUID  `json:"id"`
	TenantID  uuid.UUID  `json:"tenant_id"`
}

func (q *Queries) MarkEstimateConverted(ctx context.Context, arg MarkEstimateConvertedParams) (int64, error) {
	result, err := q.db.Exec(ctx, markEstimateConverted, arg.UpdatedBy, arg.ID, arg.TenantID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const revokeSessionByID = `-- name: RevokeSessionByID :execrows
UPDATE sessions
SET revoked_at = NOW()
WHERE id = $1
  AND tenant_id = $2
  AND revoked_at IS NULL
`

type RevokeSessionByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) RevokeSessionByID(ctx context.Context, arg RevokeSessionByIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, revokeSessionByID, arg.ID, arg.TenantID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const revokeSessionByTokenHash = `-- name: RevokeSessionByTokenHash :execrows
UPDATE sessions
SET revoked_at = NOW()
WHERE token_hash = $1
  AND revoked_at IS NULL
`

func (q *Queries) RevokeSessionByTokenHash(ctx context.Context, tokenHash string) (int64, error) {
	result, err := q.db.Exec(ctx, revokeSessionByTokenHash, tokenHash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const touchSession = `-- name: TouchSession :exec
UPDATE sessions
SET last_seen_at = NOW()
WHERE id = $1
`

func (q *Queries) TouchSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, touchSession, id)
	return err
}

const updateCustomerForEstimate = `-- name: UpdateCustomerForEstimate :one
UPDATE customers
SET
  first_name = COALESCE($1, first_name),
  last_name = COALESCE($2, last_name),
  email = COALESCE($3, email),
  phone = COALESCE($4, phone),
  updated_by = $5,
  updated_at = NOW()
WHERE id = $6
  AND tenant_id = $7
RETURNING id, tenant_id, first_name, last_name, email, phone, created_by, updated_by, created_at, updated_at
`

type UpdateCustomerForEstimateParams struct {
	FirstName *string    `json:"first_name"`
	LastName  *string    `json:"last_name"`
	Email     *string    `json:"email"`
	Phone     *string    `json:"phone"`
	UpdatedBy *uuid.UUID `json:"updated_by"`
	ID        uuid.UUID  `json:"id"`
	TenantID  uuid.UUID  `json:"tenant_id"`
}

func (q *Queries) UpdateCustomerForEstimate(ctx context.Context, arg UpdateCustomerForEstimateParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomerForEstimate,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.UpdatedBy,
		arg.ID,
		arg.TenantID,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEstimate = `-- name: UpdateEstimate :one
UPDATE estimates
SET
  customer_name = COALESCE($1, customer_name),
  primary_phone = COALESCE($2, primary_phone),
  secondary_phone = COALESCE($3, secondary_phone),
  email = COALESCE($4, email),
  origin_address_line1 = COALESCE($5, origin_address_line1),
  origin_city = COALESCE($6, origin_city),
  origin_state = COALESCE($7, origin_state),
  origin_postal_code = COALESCE($8, origin_postal_code),
  destination_address_line1 = COALESCE($9, destination_address_line1),
  destination_city = COALESCE($10, destination_city),
  destination_state = COALESCE($11, destination_state),
  destination_postal_code = COALESCE($12, destination_postal_code),
  move_date = COALESCE($13::date, move_date),
  pickup_time = COALESCE($14, pickup_time),
  lead_source = COALESCE($15, lead_source),
  move_size = COALESCE($16, move_size),
  location_type = COALESCE($17, location_type),
  estimated_total_cents = COALESCE($18::bigint, estimated_total_cents),
  deposit_cents = COALESCE($19::bigint, deposit_cents),
  notes = COALESCE($20, notes),
  updated_by = $21,
  updated_at = NOW()
WHERE id = $22
  AND tenant_id = $23
RETURNING id, tenant_id, estimate_number, customer_id, status, customer_name, primary_phone, secondary_phone, email, origin_address_line1, origin_city, origin_state, origin_postal_code, destination_address_line1, destination_city, destination_state, destination_postal_code, move_date, pickup_time, lead_source, move_size, location_type, estimated_total_cents, deposit_cents, notes, idempotency_key, idempotency_payload_hash, created_by, updated_by, created_at, updated_at
`

type UpdateEstimateParams struct {
	CustomerName            *string    `json:"customer_name"`
	PrimaryPhone            *string    `json:"primary_phone"`
	SecondaryPhone          *string    `json:"secondary_phone"`
	Email                   *string    `json:"email"`
	OriginAddressLine1      *string    `json:"origin_address_line1"`
	OriginCity              *string    `json:"origin_city"`
	OriginState             *string    `json:"origin_state"`
	OriginPostalCode        *string    `json:"origin_postal_code"`
	DestinationAddressLine1 *string    `json:"destination_address_line1"`
	DestinationCity         *string    `json:"destination_city"`
	DestinationState        *string    `json:"destination_state"`
	DestinationPostalCode   *string    `json:"destination_postal_code"`
	MoveDate                *time.Time `json:"move_date"`
	PickupTime              *string    `json:"pickup_time"`
	LeadSource              *string    `json:"lead_source"`
	MoveSize                *string    `json:"move_size"`
	LocationType            *string    `json:"location_type"`
	EstimatedTotalCents     *int64     `json:"estimated_total_cents"`
	DepositCents            *int64     `json:"deposit_cents"`
	Notes                   *string    `json:"notes"`
	UpdatedBy               *uuid.UUID `json:"updated_by"`
	ID                      uuid.UUID  `json:"id"`
	TenantID                uuid.UUID  `json:"tenant_id"`
}

func (q *Queries) UpdateEstimate(ctx context.Context, arg UpdateEstimateParams) (Estimate, error) {
	row := q.db.QueryRow(ctx, updateEstimate,
		arg.CustomerName,
		arg.PrimaryPhone,
		arg.SecondaryPhone,
		arg.Email,
		arg.OriginAddressLine1,
		arg.OriginCity,
		arg.OriginState,
		arg.OriginPostalCode,
		arg.DestinationAddressLine1,
		arg.DestinationCity,
		arg.DestinationState,
		arg.DestinationPostalCode,
		arg.MoveDate,
		arg.PickupTime,
		arg.LeadSource,
		arg.MoveSize,
		arg.LocationType,
		arg.EstimatedTotalCents,
		arg.DepositCents,
		arg.Notes,
		arg.UpdatedBy,
		arg.ID,
		arg.TenantID,
	)
	var i Estimate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EstimateNumber,
		&i.CustomerID,
		&i.Status,
		&i.CustomerName,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.Email,
		&i.OriginAddressLine1,
		&i.OriginCity,
		&i.OriginState,
		&i.OriginPostalCode,
		&i.DestinationAddressLine1,
		&i.DestinationCity,
		&i.DestinationState,
		&i.DestinationPostalCode,
		&i.MoveDate,
		&i.PickupTime,
		&i.LeadSource,
		&i.MoveSize,
		&i.LocationType,
		&i.EstimatedTotalCents,
		&i.DepositCents,
		&i.Notes,
		&i.IdempotencyKey,
		&i.IdempotencyPayloadHash,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateJobScheduleStatus = `-- name: UpdateJobScheduleStatus :one
UPDATE jobs
SET
  scheduled_date = COALESCE($1::date, scheduled_date),
  pickup_time = COALESCE($2, pickup_time),
  status = COALESCE($3, status),
  updated_by = $4,
  updated_at = NOW()
WHERE id = $5
  AND tenant_id = $6
RETURNING id, tenant_id, job_number, estimate_id, customer_id, status, scheduled_date, pickup_time, convert_idempotency_key, created_by, updated_by, created_at, updated_at
`

type UpdateJobScheduleStatusParams struct {
	ScheduledDate *time.Time `json:"scheduled_date"`
	PickupTime    *string    `json:"pickup_time"`
	Status        *string    `json:"status"`
	UpdatedBy     *uuid.UUID `json:"updated_by"`
	ID            uuid.UUID  `json:"id"`
	TenantID      uuid.UUID  `json:"tenant_id"`
}

func (q *Queries) UpdateJobScheduleStatus(ctx context.Context, arg UpdateJobScheduleStatusParams) (Job, error) {
	row := q.db.QueryRow(ctx, updateJobScheduleStatus,
		arg.ScheduledDate,
		arg.PickupTime,
		arg.Status,
		arg.UpdatedBy,
		arg.ID,
		arg.TenantID,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobNumber,
		&i.EstimateID,
		&i.CustomerID,
		&i.Status,
		&i.ScheduledDate,
		&i.PickupTime,
		&i.ConvertIdempotencyKey,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStorageRecordByID = `-- name: UpdateStorageRecordByID :one
UPDATE storage_record
SET
  facility = $1,
  status = $2,
  date_in = $3::date,
  date_out = $4::date,
  next_bill_date = $5::date,
  lot_number = $6,
  location_label = $7,
  vaults = $8,
  pads = $9,
  items = $10,
  oversize_items = $11,
  volume = $12,
  monthly_rate_cents = $13::bigint,
  storage_balance_cents = $14,
  move_balance_cents = $15,
  last_payment_at = $16::timestamptz,
  notes = $17,
  updated_at = NOW()
WHERE id = $18
  AND tenant_id = $19
RETURNING id, tenant_id, job_id, facility, status, date_in, date_out, next_bill_date, lot_number, location_label, vaults, pads, items, oversize_items, volume, monthly_rate_cents, storage_balance_cents, move_balance_cents, last_payment_at, notes, created_at, updated_at
`

type UpdateStorageRecordByIDParams struct {
	Facility            string     `json:"facility"`
	Status              string     `json:"status"`
	DateIn              *time.Time `json:"date_in"`
	DateOut             *time.Time `json:"date_out"`
	NextBillDate        *time.Time `json:"next_bill_date"`
	LotNumber           *string    `json:"lot_number"`
	LocationLabel       *string    `json:"location_label"`
	Vaults              int32      `json:"vaults"`
	Pads                int32      `json:"pads"`
	Items               int32      `json:"items"`
	OversizeItems       int32      `json:"oversize_items"`
	Volume              int32      `json:"volume"`
	MonthlyRateCents    *int64     `json:"monthly_rate_cents"`
	StorageBalanceCents int64      `json:"storage_balance_cents"`
	MoveBalanceCents    int64      `json:"move_balance_cents"`
	LastPaymentAt       *time.Time `json:"last_payment_at"`
	Notes               *string    `json:"notes"`
	ID                  uuid.UUID  `json:"id"`
	TenantID            uuid.UUID  `json:"tenant_id"`
}

func (q *Queries) UpdateStorageRecordByID(ctx context.Context, arg UpdateStorageRecordByIDParams) (StorageRecord, error) {
	row := q.db.QueryRow(ctx, updateStorageRecordByID,
		arg.Facility,
		arg.Status,
		arg.DateIn,
		arg.DateOut,
		arg.NextBillDate,
		arg.LotNumber,
		arg.LocationLabel,
		arg.Vaults,
		arg.Pads,
		arg.Items,
		arg.OversizeItems,
		arg.Volume,
		arg.MonthlyRateCents,
		arg.StorageBalanceCents,
		arg.MoveBalanceCents,
		arg.LastPaymentAt,
		arg.Notes,
		arg.ID,
		arg.TenantID,
	)
	var i StorageRecord
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobID,
		&i.Facility,
		&i.Status,
		&i.DateIn,
		&i.DateOut,
		&i.NextBillDate,
		&i.LotNumber,
		&i.LocationLabel,
		&i.Vaults,
		&i.Pads,
		&i.Items,
		&i.OversizeItems,
		&i.Volume,
		&i.MonthlyRateCents,
		&i.StorageBalanceCents,
		&i.MoveBalanceCents,
		&i.LastPaymentAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const userHasPermission = `-- name: UserHasPermission :one
SELECT EXISTS (
  SELECT 1
  FROM user_roles ur
  JOIN roles r ON r.id = ur.role_id
  JOIN role_permissions rp ON rp.role_id = r.id
  JOIN permissions p ON p.id = rp.permission_id
  WHERE ur.user_id = $1
    AND ur.tenant_id = $2
    AND r.tenant_id = $2
    AND p.name = $3
) AS has_permission
`

type UserHasPermissionParams struct {
	UserID     uuid.UUID `json:"user_id"`
	TenantID   uuid.UUID `json:"tenant_id"`
	Permission string    `json:"permission"`
}

func (q *Queries) UserHasPermission(ctx context.Context, arg UserHasPermissionParams) (bool, error) {
	row := q.db.QueryRow(ctx, userHasPermission, arg.UserID, arg.TenantID, arg.Permission)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}
